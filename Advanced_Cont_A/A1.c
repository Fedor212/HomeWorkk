/*Шифр Цезаря
На стандартном потоке ввода задается целое неотрицательное число N
 и последовательность допустимых символов в кодировке ASCII,
  оканчивающаяся точкой. Допустимые символы - латинские буквы 'a' ... 'z', 'A' ... 'Z' и пробел.
   Требуется закодировать латинские буквы ('a' ... 'z', 'A' ... 'Z') шифром Цезаря,
    пробелы вывести без изменения. Число N задает сдвиг в шифре.
     Шифр Цезаря заключается в следующем преобразовании.
      Пусть буквы алфавита пронумерованы от 0 до K - 1, где K - число символов в алфавите.
       Тогда символ с номером n кодируется символом с номером p = (n + N) mod K (mod - операция взятия остатка).
        На стандартном потоке вывода напечатать зашифрованное сообщение, оканчивающееся точкой.
         Преобразование требуется выполнять независимо для заглавных и строчных латинских букв.
          Указание: использовать массивы запрещается.
Examples
Input
0 Hello World.
Output
Hello World.
Input
1 Aa.
Output
Bb.
Input
3 ppc.
Output
ssf. */

#include <math.h>
#include <stdio.h>
#include <stdint.h>
//#include <locale.h>

int a=0;
char cpace;
char b = 0;
int bb = 0;
int bool = 0;
int main(void)
{
    scanf ("%d", &a);
    //printf ("Prov: %d\n", a);
    a = a % 26;
    scanf ("%c", &b);
    while (b != 46)
    {
        if (b > 64 && b < 91)
        {
            bb = b;
            bb = bb + a;
            if (bb > 90)
            {
                bb = bb % 90 + 64;
            }

        }
        else if (b > 96 && b < 123)
        {
            bb = b + a;

            if (bb > 122)
            {
                bb = bb % 122 + 96;
            }
        }
        else
        {
            bb = 32;
        }
        if ((bool == 0 && bb != 32) || (bool > 0))
        {
            printf ("%c", bb);
        }
        bool++;
        scanf ("%c", &b);
    }
    printf (".");
    return 0;

}
